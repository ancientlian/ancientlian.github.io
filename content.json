{"meta":{"title":"Ancientlian的博客","subtitle":null,"description":"众所周知，这是一个博客","author":"Ancientlian","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-12-11T04:56:18.000Z","updated":"2018-12-11T08:00:18.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-11T08:02:07.000Z","updated":"2018-12-24T14:44:48.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"本人擅长Ai、Fw、Fl、Br、Ae、Pr、Id、Ps等软件的安装与卸载，精通CSS、JavaScript、PHP、ASP、C、C＋＋、C#、Java、Ruby、Perl、Lisp、python、Objective-C、ActionScript、Pascal、spss、sas等单词的拼写，熟悉Windows、Linux、Mac、Android、IOS、WP8等系统的开关机。 本人学识渊博、经验丰富，代码风骚、效率恐怖，c/c++、java、php无不精通，熟练掌握各种框架，深山苦练20余年，一天只睡4小时，千里之外定位问题，瞬息之间修复上线。身体强壮、健步如飞，可连续编程100小时不休息，讨论技术方案5小时不喝水，上至带项目、出方案，下至盗账号、威胁pm，啥都能干。 泡面矿泉水已备好，学校不支持编程已辍学，家人不支持编程已断绝关系，老婆不支持编程已离婚，小孩不支持编程已送孤儿院，备用电源万兆光纤永不断电断网，门口已埋雷无人打扰。 当然以上都是假的！ ~~~~如果文章有错误欢迎联系我：QQ：940262336邮件：940262336@qq.com"},{"title":"Tags","date":"2018-12-11T04:51:12.000Z","updated":"2018-12-11T08:00:20.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python中的字典、列表及元组简单认识","slug":"Python中的字典、列表及元组简单认识","date":"2019-11-14T14:36:53.000Z","updated":"2019-11-14T14:25:58.553Z","comments":true,"path":"2019/11/14/Python中的字典、列表及元组简单认识/","link":"","permalink":"http://yoursite.com/2019/11/14/Python中的字典、列表及元组简单认识/","excerpt":"本文主要简单介绍Python当中字典（Dictionary）、列表（List）以及元组（Tuple）的基础知识。 简介在我们的python中有一些特有的内置数据类型，其中包括有dictionary（字典）、tuple（元组）、list（列表）。 DictionaryPython的内置数据类型之一，定义了键值之间一对一的关系。 定义123d = &#123;\"test1\":\"test1\",\"test2\":111&#125;&gt;&gt;&gt;d[\"test2\"] #引用方法&gt;&gt;&gt;111 每一个元素都是一个key-value对，整个元素集合用{}括起来。不允许使用值获取key。dictionary的值可以混用，包括字符串、整数、对象、甚至是dictionary。但是key会严格一点。","text":"本文主要简单介绍Python当中字典（Dictionary）、列表（List）以及元组（Tuple）的基础知识。 简介在我们的python中有一些特有的内置数据类型，其中包括有dictionary（字典）、tuple（元组）、list（列表）。 DictionaryPython的内置数据类型之一，定义了键值之间一对一的关系。 定义123d = &#123;\"test1\":\"test1\",\"test2\":111&#125;&gt;&gt;&gt;d[\"test2\"] #引用方法&gt;&gt;&gt;111 每一个元素都是一个key-value对，整个元素集合用{}括起来。不允许使用值获取key。dictionary的值可以混用，包括字符串、整数、对象、甚至是dictionary。但是key会严格一点。 修改我们可以对字典其中的数据进行修改。12d[\"test2\"] = \"222\"d[\"test3\"] = \"test3\" #修改不存在的，实际会添加一个新的键值对 Dictionary不能使用重复的key，它其实会对原来的key进行重新赋值。在任何的时候都可以加入新的key-value对，这种语法同修改存在的值是一样的。Dictionary是无序的！Dictionary是大小写敏感的！123456d = &#123;&#125;d[\"key\"] = \"value\"d[\"Key\"] = \"other value\"d[\"Key\"] = \"change value\" #修改&gt;&gt;&gt;d&gt;&gt;&gt;&#123;'Key': 'change value', 'key': 'value'&#125; 删除我们使用简单的del来进行dictionary元素的删除，clear 从一个 dictionary 中清除所有元素。1234567d = &#123;111:\"test1\", \"test2\":\"222\", \"test3\":333&#125;del d[111]&gt;&gt;&gt;d&gt;&gt;&gt;&#123;\"test2\":\"222\", \"test3\":333&#125;d.clean()&gt;&gt;&gt;d&gt;&gt;&gt;&#123;&#125; # 没有元素的字典 Listlist是使用最频繁的数据类型，它更像java中的数组，或者说是ArrayList，可以保存任意对象，并且可以在增加新元素时动态扩展。 定义12345li = [\"a\", \"b\", \"c\", \"z\", \"example\"]&gt;&gt;&gt;li[0]&gt;&gt;&gt;'a'&gt;&gt;&gt;li[4]&gt;&gt;&gt;'example' List是一个方括号包括起来的有序元素的集合。从下标0开始进行计数，第一个非空元素为li[0]，如果查找越界会报错list index out of range。 查找123li = [1,2,3]&gt;&gt;&gt;li[-1]&gt;&gt;&gt;3 负数索引从list尾部向前计数，最后一个非空元素为list[-1]，如果查找越界会报错list index out of range。 分片（slice）123456789li = [1,2,3,4,5,6]&gt;&gt;&gt;li[1:3]&gt;&gt;&gt;[2,3]&gt;&gt;&gt;li[1:-1]&gt;&gt;&gt;[2,3,4,5]&gt;&gt;&gt;li[-3:-1]&gt;&gt;&gt;[4,5]&gt;&gt;&gt;li[-1:-3]&gt;&gt;&gt;[] 我们可以通过两个索引切片得到一个list子集，返回一个新的list，注意切片包括第一个索引不包括第二个索引。list支持切片的简写 1234567li = [1,2,3,4,5]&gt;&gt;&gt;li[:3]&gt;&gt;&gt;[1,2,3]&gt;&gt;&gt;li[3:]&gt;&gt;&gt;[4,5]&gt;&gt;&gt;li[:]&gt;&gt;&gt;[1,2,3,4,5] li[:3]等同于li[0:3]，li[3:]等同于li[3:5]。两边分片索引全部省略，这将包括所有的list元素。 增加我们有三种常用的方法来给list增加元素，分别为append()、insert()、extend()。 12345678910li = [1,2,3]li.append(4)&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,3,4]li.insert(2,\"a\")&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,'a',3,4]li.extend([1,3])&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,'a',3,4,1,3] append()是向list末尾追加单个元素insert()是元素插入到索引位置。如上所见，元素并不唯一，同时出现了两个1元素。extend()用以连接list。 extend与append的区别12345678910li = [1,2,3]li.extend([4,5])&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,3,4,5] #len = 5li.append([4,5])&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,3,[4,5]] #len = 4&gt;&gt;&gt;li[-1]&gt;&gt;&gt;[4,5] 如上所见，extend只接受一个list参数，且依次添加到原list。append接受一个任何数据类型的参数，且仅仅追加一项到list尾部。如上追加的为一个list，list可以包含任何数据类型，自然也包括list。明确使用extend和append的场合，避免产生不想要的效果。 查找1234567li = [1,2,3,2]&gt;&gt;&gt;li.index(2)&gt;&gt;&gt;1&gt;&gt;&gt;li.index(2,2)&gt;&gt;&gt;3&gt;&gt;&gt;\"a\" in li&gt;&gt;&gt;False index查找一个值首次出现的索引值。当然我们也可以指定第n个出现m的索引值index(m,n)。如果未找到，python会抛出一个异常ValueError: list.index(x): x not in list我们可以使用in测试一个值是否在list内。存在返回True，否则False。 删除1234567li = [1,2,1,3,1,4]&gt;&gt;&gt;li.remove(1)&gt;&gt;&gt;[2,1,3,1,4]&gt;&gt;&gt;li.pop()&gt;&gt;&gt;4&gt;&gt;&gt;li&gt;&gt;&gt;[2,1,3,1] remove从列表中删除一个值的首次出现，并不会返回值。如果没有找到这个值，会抛出异常ValueError: list.remove(x): x not in listpop首先会删除list最后的一个值，并返回。 list的运算符12345678910li = [1,2,3]li = li + ['a', 'b']&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,3,'a','b']li += ['new']&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,3,'a','b','new']li = [1,2]*3&gt;&gt;&gt;li&gt;&gt;&gt;[1,2,1,2,1,2] list可以用+运算符连接，返回一个添加后的列表，等同于extend()。但extend修改存在的list，大型list，extend执行速度更快。 TupleTuple是不可变的list。1234567&gt;&gt;&gt;t = (1,3,2)&gt;&gt;&gt;t[0]1&gt;&gt;&gt;t[-1]2&gt;&gt;&gt;t[1:3](3,2) tuple使用小括号进行定义，且按定义顺序进行排序。tuple支持负数索引查找，且同样可以使用切片，返回一个新的tuple。tuple不存在append、extend、remove、pop、index等方法。但是支持in来查看元素是否存在。","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://yoursite.com/categories/Python基础/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"重新部署","slug":"如何换新的电脑设置hexo","date":"2019-11-13T14:41:45.000Z","updated":"2019-11-13T14:50:11.830Z","comments":true,"path":"2019/11/13/如何换新的电脑设置hexo/","link":"","permalink":"http://yoursite.com/2019/11/13/如何换新的电脑设置hexo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Django中的Meta","slug":"Django中的Meta","date":"2018-12-19T14:36:53.000Z","updated":"2018-12-24T14:32:12.000Z","comments":true,"path":"2018/12/19/Django中的Meta/","link":"","permalink":"http://yoursite.com/2018/12/19/Django中的Meta/","excerpt":"在Django模型类中经常会嵌套一个内部类，他的名字为Meta，它一般用于定义一些Django模型类的行为特性。也就是通过一个内嵌类 “class Meta” 给你的 model 定义元数据。 定义方式为：12345class Foo(models.Model): example = models.CharField(maxlength=10) class Meta: # 各种行为模式 #","text":"在Django模型类中经常会嵌套一个内部类，他的名字为Meta，它一般用于定义一些Django模型类的行为特性。也就是通过一个内嵌类 “class Meta” 给你的 model 定义元数据。 定义方式为：12345class Foo(models.Model): example = models.CharField(maxlength=10) class Meta: # 各种行为模式 # 属性abstract这个属性是定义当前的模型是不是一个抽象类。所谓抽象类是不会对应数据库表的。一般我们用它来归纳一些公共属性字段，然后继承它的子类可以继承这些字段。 Options.abstract如果 abstract = True 这个model就是一个抽象类 app_label这个属性用于当你的模型不在默认的应用程序包下的models.py文件中，需要重新指定你这个模型所属应用程序。 Options.app_label如果一个model定义在默认的models.py，例如如果你的app的models在另一个myapp.models子模块下，你必须定义app_label让Django知道它属于哪一个appapp_label = &#39;myapp&#39; db_tabledb_table是指定自定义数据库表名。Django有一套默认的按照一定规则生成数据模型对应的数据库表。Options.db_table定义该model在数据库中的表名称： db_table = &#39;Students&#39;默认的命名方式为app_label + ‘_’ + module_name 作为表名 db_teblespaceOptions.db_teblespace定义这个model所使用的数据库表空间比如Oracle。你可以通过db_tablespace来指定这个模型对应的数据库表放在哪个数据库表空间。在项目的settings中定义。 get_latest_byOptions.get_latest_by在model中指定Manager上的lastest（）管理方法按照DateField或者DateTimeField类型的字段进行选取，默认使用指定字段来排序 managedOptions.managed默认值为True，这意味着Django可以使用syncdb和reset等命令来创建或移除对应的数据库。默认值为True,如果你不希望这么做，可以把manage的值设置为False order_with_respect_to这个属性一般用于多对多的关系中，它指向一个关联对象，就是说关联对象找到这个对象后它是经过排序的。指定这个属性后你会得到一个get_xxx_order()和set_xxx_order()的方法，通过它们你可以设置或者回去排序的对象 ordering这个属性是告诉Django模型对象返回的记录结果集是按照哪个字段排序的。这是一个字符串的元组或列表，没有一个字符串都是一个字段和用一个可选的表明降序的’-‘构成。当字段名前面没有’-‘时，将默认使用升序排列。使用’?’将会随机排列 ordering=[‘order_date’] # 按订单升序排列 ordering=[‘-order_date’] # 按订单降序排列，-表示降序 ordering=[‘?order_date’] # 随机排序，？表示随机 ordering=[‘-pub_date’,’author’] # 以pub_date为降序，在以author升序排列 permissionspermissions主要是为了在Django Admin管理模块下使用的，如果你设置了这个属性可以让指定的方法权限描述更清晰可读。Django自动为每个设置了admin的对象创建添加，删除和修改的权限。permissions = ((&#39;can_deliver_pizzas&#39;,&#39;Can deliver pizzas&#39;)) proxy这是为了实现代理模型使用的，如果proxy = True,表示model是其父的代理 model unique_togetherunique_together这个属性用于：当你需要通过两个字段保持唯一性时使用。比如假设你希望，一个Person的FirstName和LastName两者的组合必须是唯一的，那么可以这样设置：unique_together = ((&quot;first_name&quot;, &quot;last_name&quot;),)一个ManyToManyField不能包含在unique_together中。如果你需要验证关联到ManyToManyField字段的唯一验证，尝试使用signal(信号)或者明确指定through属性。 verbose_nameverbose_name的用于给你的模型类起一个更可读的名字，一般定义为中文，例如：verbose_name = &quot;学校&quot; verbose_name_plural这个属性是指定模型的复数形式，比如：verbose_name_plural = &quot;学校&quot;如果不指定Django会自动在模型名称后加一个’s’","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Django配置mysql","slug":"Django中配置mysql","date":"2018-12-19T14:36:53.000Z","updated":"2018-12-24T14:35:12.000Z","comments":true,"path":"2018/12/19/Django中配置mysql/","link":"","permalink":"http://yoursite.com/2018/12/19/Django中配置mysql/","excerpt":"首先装好mysql数据库，django框架里面默认用的是sqlite的数据库 配置在项目文件夹的settings.py中配置： 12345678910111213DATABASES = &#123; 'default': &#123; # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': 'tablename', # 你要存储数据的库名，事先要创建之 'USER': 'root', # 数据库用户名 'PASSWORD': 'mysql', # 密码 #'HOST': 'localhost', # 主机 'HOST':'127.0.0.1', # 制定mysql数据库所在电脑ip，如果是本机直接写‘localhost’ 'PORT': '3306', # 数据库使用的端口 &#125;&#125;","text":"首先装好mysql数据库，django框架里面默认用的是sqlite的数据库 配置在项目文件夹的settings.py中配置： 12345678910111213DATABASES = &#123; 'default': &#123; # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': os.path.join(BASE_DIR, 'db.sqlite3'), 'ENGINE': 'django.db.backends.mysql', # 数据库引擎 'NAME': 'tablename', # 你要存储数据的库名，事先要创建之 'USER': 'root', # 数据库用户名 'PASSWORD': 'mysql', # 密码 #'HOST': 'localhost', # 主机 'HOST':'127.0.0.1', # 制定mysql数据库所在电脑ip，如果是本机直接写‘localhost’ 'PORT': '3306', # 数据库使用的端口 &#125;&#125; 数据库的迁移仅仅在settings里面配置好数据库的端口连接是还不够的，我们还需在几个步骤： 首先：在python的虚拟环境中需要安装pymysql，命令为pip install pymysql（注：python2使用pip install mysql-python 来安装mysql-python 然后在项目文件夹下的-init-.py里面导入添加 12import pymysqlpymysql.install_as_MySQLdb() 之后就能在终端中进行数据库的迁移了： 12python manage.py makemigrationspython manage.py migrate 这样就简单完成了mysql数据库的配置了。","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"Django配置redis","slug":"Django配置redis","date":"2018-12-19T14:36:53.000Z","updated":"2018-12-24T14:35:40.000Z","comments":true,"path":"2018/12/19/Django配置redis/","link":"","permalink":"http://yoursite.com/2018/12/19/Django配置redis/","excerpt":"在django 中配置redis的连接 linux安装1$ pip install django-redis 安装完成显示：Successfully installed django-redis-4.10.0 redis-3.0.1 settings配置settings里面的配置为：","text":"在django 中配置redis的连接 linux安装1$ pip install django-redis 安装完成显示：Successfully installed django-redis-4.10.0 redis-3.0.1 settings配置settings里面的配置为：1234567891011121314151617# redis配置CACHES = &#123; 'default': &#123; 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://127.0.0.1:6379/5', \"OPTIONS\": &#123; \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", &#125;, &#125;, 'session':&#123; 'BACKEND': 'django_redis.cache.RedisCache', 'LOCATION': 'redis://127.0.0.1:6379/6', \"OPTIONS\": &#123; \"CLIENT_CLASS\": \"django_redis.client.DefaultClient\", &#125;, &#125;,&#125; 这里注意的是我们get_redis_connection的方法默认使用的是default里面定义的数据库 我们看get_redis_connection的方法定义就明白了： 12345678910111213141516def get_redis_connection(alias='default', write=True): \"\"\" Helper used for obtaining a raw redis client. \"\"\" from django.core.cache import caches cache = caches[alias] if not hasattr(cache, \"client\"): raise NotImplementedError(\"This backend does not support this feature\") if not hasattr(cache.client, \"get_client\"): raise NotImplementedError(\"This backend does not support this feature\") return cache.client.get_client(write)","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"mysql数据库用户以及权限","slug":"mysql数据库用户以及权限","date":"2018-12-19T14:36:53.000Z","updated":"2018-12-24T14:36:24.000Z","comments":true,"path":"2018/12/19/mysql数据库用户以及权限/","link":"","permalink":"http://yoursite.com/2018/12/19/mysql数据库用户以及权限/","excerpt":"进入mysql界面，进行用户的基本相关操作 查看当前有的账户名称mysql&gt; SELECT DISTINCT CONCAT(&#39;User: &#39;&#39;&#39;,user,&#39;&#39;&#39;@&#39;&#39;&#39;,host,&#39;&#39;&#39;;&#39;) AS query FROM mysql.user; 或者直接：select user,host from mysql.user; 创建用户","text":"进入mysql界面，进行用户的基本相关操作 查看当前有的账户名称mysql&gt; SELECT DISTINCT CONCAT(&#39;User: &#39;&#39;&#39;,user,&#39;&#39;&#39;@&#39;&#39;&#39;,host,&#39;&#39;&#39;;&#39;) AS query FROM mysql.user; 或者直接：select user,host from mysql.user; 创建用户 通用命令为：CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;; Or命令2：当数据库存在用户的时候GRANT会对用户进行授权，但当数据库不存在该用户的时候，就会创建相应的用户并进行授权。（说明上面那步是多余的，并且他创建之后还要赋权限才能使用=.=!）GRANT &lt;privileges&gt; ON username IDENTIFIED BY &#39;password&#39;&lt;WITH GRANT OPTION&gt;; 说明： username：创建的用户名 host：指定用户可以在哪个主机登录。本地用户用’localhost’，从任意远程主机登录，用通配符‘%’ password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器 授权命令1：GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; 说明： privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL 用这种命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令: 1GRANT privileges ON databasename.tablename TO &apos;username&apos;@&apos;host&apos; WITH GRANT OPTION; 撤销用户权限命令：REVOKE privilege ON databasename.tablename FROM &#39;username&#39;@&#39;host&#39;; 注意：假如你在给用户&#39;name&#39;@&#39;%&#39;授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO &#39;name&#39;@&#39;%&#39;，则在使用REVOKE SELECT ON *.* FROM &#39;name&#39;@&#39;%&#39;;命令并不能撤销该用户对test数据库中user表的SELECT 操作。相反，如果授权使用的是GRANT SELECT ON *.* TO &#39;name&#39;@&#39;%&#39;;则REVOKE SELECT ON test.user FROM &#39;name&#39;@&#39;%&#39;;命令也不能撤销该用户对test数据库中user表的Select权限。 删除用户命令：DROP USER &#39;username&#39;@&#39;host&#39;; 也可以是：Delete FROM user Where User=&#39;username&#39; and Host=&#39;host&#39;; 如果就修改当前用户的密码，可以直接：SET PASSWORD = PASSWORD(&quot;newpassword&quot;); 修改用户密码命令：update mysql.user set password=password(&#39;new_password&#39;) where User=&quot;username&quot; and Host=&quot;host&quot;; 也可以是：SET PASSWORD FOR &#39;username&#39;@&#39;host&#39; = PASSWORD(&#39;newpassword&#39;); 备注如果授权和删除之后没有显示，可以用flush privileges;刷新一下系统权限表 附：数据库/数据表/数据列权限：Alter: 修改已存在的数据表(例如增加/删除列)和索引。Create: 建立新的数据库或数据表。Delete: 删除表的记录。Drop: 删除数据表或数据库。INDEX: 建立或删除索引。Insert: 增加表的记录。Select: 显示/搜索表的记录。Update: 修改表中已存在的记录。 全局管理MySQL用户权限： file: 在MySQL服务器上读写文件。PROCESS: 显示或杀死属于其它用户的服务线程。RELOAD: 重载访问控制表，刷新日志等。SHUTDOWN: 关闭MySQL服务。 特别的权限： ALL: 允许做任何事(和root一样)。USAGE: 只允许登录–其它什么也不允许做。","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"图书小项目理解Django（二）","slug":"图书小项目理解Django（二）","date":"2018-12-18T14:36:53.000Z","updated":"2018-12-19T15:15:16.000Z","comments":true,"path":"2018/12/18/图书小项目理解Django（二）/","link":"","permalink":"http://yoursite.com/2018/12/18/图书小项目理解Django（二）/","excerpt":"接上文： 信息展示页设计url在views里面： 123456789from django.shortcuts import render from booktest.models import BookInfodef index(request): '''显示图书信息''' # 1. 查询出所有的图书信息 books = BookInfo.objects.all() # 2. 设置模板，使用模板 return render(request , 'booktest/index.html' , &#123;'books':books&#125;)","text":"接上文： 信息展示页设计url在views里面： 123456789from django.shortcuts import render from booktest.models import BookInfodef index(request): '''显示图书信息''' # 1. 查询出所有的图书信息 books = BookInfo.objects.all() # 2. 设置模板，使用模板 return render(request , 'booktest/index.html' , &#123;'books':books&#125;) 模板的创建新建空directory名为tempates 在setting里的TEMPLATES处配置设定模板：&#39;DIRS&#39;: [os.path.join(BASE_DIR,&#39;templates&#39;)],#设置模板目录 新建app同名文件夹，内建index.html 配置urls在文件bookM内配置urls为： 1234urlpatterns = [ url(r'^admin/', include(admin.site.urls)), url(r'^' , include('booktest.urls')), #包含boottest的urls文件] 在app文件（也就是booktest）内新建urls.py，其内容为： 123456789from django.conf.urls import urlfrom booktest import viewsurlpatterns = [ url(r'^index$' , views.index), #图书信息页面 url(r'^create$' , views.create),#图书新增 url(r'^delete(\\d+)$',views.delete)#图书删除 # （\\d+）的含义：让django进行地址匹配的时候能作为参数传递给views视图] 设计html编写index.html文件，内容为： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图书信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"/create\"&gt;新增一本图书&lt;/a&gt;&#123;#如果create不加前面的/,而url里面刚好又在后面加了/,例如：r'^index/$'，#&#125;&#123;#则会导致a标签访问的是http://127.0.0.1:8000/index/create，#&#125;&#123;#而不是我们想要的http://127.0.0.1:8000/create，这样就会产生页面不存在的访问错误#&#125;&lt;ul&gt; &#123;% for book in books %&#125; &lt;li&gt;&#123;&#123; book.btitle &#125;&#125;----&lt;a href=\"/delete&#123;&#123; book.id &#125;&#125;\"&gt;删除&lt;/a&gt;&lt;/li&gt; &#123;% endfor %&#125;&lt;/ul&gt;&lt;/body&gt;&lt;/html&gt; 业务逻辑在views里编写业务逻辑 新增一本书：123456789101112def create(request): '''新增加一本图书''' # 1. 创建Bookinfo对象 b = BookInfo() b.btitle = '流星蝴蝶剑' b.bpub_date = date(1990,1,1) # 2. 保存进数据库 b.save() # 3. 返回应答，让浏览器返回首页，也就是再访问/index,重定向 #页面重定向：服务器不返回页面，而是告诉浏览器再去请求别的url地址 #return HttpResponse('添加成功okokokok!!') #这里不是给浏览器返回一个内容 return HttpResponseRedirect('/index') 删除一本书：12345678910def delete(request , bid): '''删除点击的图书''' # 1. 通过bid获取图书的对象 book = BookInfo.objects.get(id = bid) # 2. 删除 book.delete() # 3. 重定向，让浏览器重新访问/index #return HttpResponseRedirect('/index') # 上述函数可以简写为 return redirect('/index') 附views页全代码及效果展示","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"图书小项目理解Django（一）","slug":"图书小项目理解Django（一）","date":"2018-12-18T13:36:53.000Z","updated":"2018-12-19T14:54:58.000Z","comments":true,"path":"2018/12/18/图书小项目理解Django（一）/","link":"","permalink":"http://yoursite.com/2018/12/18/图书小项目理解Django（一）/","excerpt":"在Django项目中，我们会对扑面而来的众多框架内置生成文件望而生畏，这里通过一个简单的图书馆管理小例子来简单说明Django内置各部分的作用，便于快速理解Django 前期准备进入虚拟环境（如何进入虚拟环境） 终端输入： 123django-admin startproject bookM #创建工程cd bookM #进入到项目文件python manage.py startapp booktest #创建app","text":"在Django项目中，我们会对扑面而来的众多框架内置生成文件望而生畏，这里通过一个简单的图书馆管理小例子来简单说明Django内置各部分的作用，便于快速理解Django 前期准备进入虚拟环境（如何进入虚拟环境） 终端输入： 123django-admin startproject bookM #创建工程cd bookM #进入到项目文件python manage.py startapp booktest #创建app 建立模型类这样就已经基本创建好项目所用，我使用的IDE是Pycharm打开后我们进入到booktest的models开始创建模型类： 123456789101112131415161718192021222324252627from django.db import models# Create your models here.class BookInfo(models.Model): '''图书模型类''' #图书名称 btitle = models.CharField(max_length = 20) #出版日期 bpub_date = models.DateField() #阅读量 bread = models.IntegerField(default = 0) #评论量 bcomment = models.IntegerField(default = 0) #删除标记 isDelete = models.BooleanField(default=False)class HeroInfo(models.Model): '''英雄人物模型类''' hname = models.CharField(max_length = 20) #性别 hgender = models.BooleanField(default = False) #备注 hcomment = models.CharField(max_length = 200) #关系属性 hbook = models.ForeignKey('Bookinfo') # 删除标记 isDelete = models.BooleanField(default=False) 现在类对应的表还没有，所以还需要迁移。 迁移第一步：终端输入：python manage.py makemigrations 第二步：生成迁移文件之后输入python manage.py migrate，根据迁移文件生成mysql的表 你可以在终端中通过mysql简单查看是否输入进去导入成功 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mysql&gt; use bookM；mysql&gt; show tables；--其中有--+----------------------------+| Tables_in_bookM |+----------------------------+| auth_group || auth_group_permissions || auth_permission || auth_user || auth_user_groups || auth_user_user_permissions || booktest_bookinfo || booktest_heroinfo || django_admin_log || django_content_type || django_migrations || django_session |+----------------------------+12 rows in set (0.00 sec)mysql&gt; desc booktest_bookinfo；+-----------+-------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-----------+-------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || btitle | varchar(20) | NO | | NULL | || bpub_date | date | NO | | NULL | || bread | int(11) | NO | | NULL | || bcomment | int(11) | NO | | NULL | || isDelete | tinyint(1) | NO | | NULL | |+-----------+-------------+------+-----+---------+----------------+6 rows in set (0.01 sec)mysql&gt; desc booktest_heroinfo;+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || hname | varchar(20) | NO | | NULL | || hgender | tinyint(1) | NO | | NULL | || hcomment | varchar(200) | NO | | NULL | || isDelete | tinyint(1) | NO | | NULL | || hbook_id | int(11) | NO | MUL | NULL | |+----------+--------------+------+-----+---------+----------------+6 rows in set (0.00 sec)---添加一点数据---mysql&gt;insert into booktest_bookinfo(btitle,bpub_date,bread,bcomment,isDelete) values(&apos;射雕英雄传&apos;,&apos;1980-5-1&apos;,12,34,0)；mysql&gt;insert into booktest_heroinfo(hname,hgender,hbook_id,hcomment,isDelete) values(&apos;郭靖&apos;,1,1,&apos;降龙十八掌&apos;,0),--- 转下文","categories":[{"name":"django","slug":"django","permalink":"http://yoursite.com/categories/django/"}],"tags":[{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Redis基础认识","slug":"Redis基础认识","date":"2018-12-14T13:36:53.000Z","updated":"2018-12-19T14:55:54.000Z","comments":true,"path":"2018/12/14/Redis基础认识/","link":"","permalink":"http://yoursite.com/2018/12/14/Redis基础认识/","excerpt":"在学习的过程当中，我们或多或少的都会接触到redis，比如说在我们的web项目中，如果想添加历史浏览记录，那肯定要用到数据库，但如果直接上手mysql就显得的过于大材小用了，此时redis也就应运而生。不过首先需要介绍一下什么是nosql。 NoSQL介绍NoSQL：一类新出现的数据库（not only sql），特点有： 不支持sql语法 存储结构和传统关系型数据库（比如mysql，oracle，sql server）中的关系表不同，nosql中存储的数据都是K-V形式。而Redis 就是一个高性能的key-value数据库。 NoSQL的世界里没有一种通用的语言，每种NoSQL数据库都有自己的api和语法，以及擅长的业务场景 NoSQL产品种类比如有： Mongodb Redis Hbase hadoop Cassandra hadoop","text":"在学习的过程当中，我们或多或少的都会接触到redis，比如说在我们的web项目中，如果想添加历史浏览记录，那肯定要用到数据库，但如果直接上手mysql就显得的过于大材小用了，此时redis也就应运而生。不过首先需要介绍一下什么是nosql。 NoSQL介绍NoSQL：一类新出现的数据库（not only sql），特点有： 不支持sql语法 存储结构和传统关系型数据库（比如mysql，oracle，sql server）中的关系表不同，nosql中存储的数据都是K-V形式。而Redis 就是一个高性能的key-value数据库。 NoSQL的世界里没有一种通用的语言，每种NoSQL数据库都有自己的api和语法，以及擅长的业务场景 NoSQL产品种类比如有： Mongodb Redis Hbase hadoop Cassandra hadoop NoSQL和SQL数据库比较： 适用场景不同：sql数据库适合用于关系特别复杂的数据查询场景，nosql相反 “事务”特性的支持：sql对事务的支持非常完善，而nosql基本不支持事务。（注：“事务”：一组sql操作，要么都成功，要么都失败） 两者在不断地取长补短，呈现融合趋势 Redis简介 Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由Pivotal赞助。 Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。（来源：百度词条） Redis特性 与其他key-value缓存产品一样：支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 同时提供list,set,zset,hash等数据结构的存储。 支持数据的备份，即master-slave模式的数据备份 Redis 优势 性能极高 - Redis能读的速度是110000次/s，写的速度为81000次/s。 丰富的数据类型 - 支持二进制案例的 String，Lists，Hashes，Sets 及 Orderd Sets 数据类型操作。 原子 - Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。 Redis应用场景 用来做缓存（ehcache/memcached）–redis的所有数据是放在内存中的（内存数据库） 可以在某些特定应用场景下替代传统数据库 – 比如社交应用 在一些大型系统，特定功能：session共享，购物车 也有比如排行榜应用，取TOP N操作。 按照用户投票和时间排序等等。 只要你有丰富的想象力，redis有无限的惊喜 推荐阅读 redis官方网站 redis中文官网","categories":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"}]},{"title":"论-JavaScript、jQuery、AJAX、JSON及四者关系","slug":"论-JavaScript、jQuery、AJAX、JSON及四者关系","date":"2018-12-12T14:36:53.000Z","updated":"2019-11-13T14:49:21.454Z","comments":true,"path":"2018/12/12/论-JavaScript、jQuery、AJAX、JSON及四者关系/","link":"","permalink":"http://yoursite.com/2018/12/12/论-JavaScript、jQuery、AJAX、JSON及四者关系/","excerpt":"在学习前端的过程中，经常被各种各样的语法名词搞混，这里简单归纳下容易混淆的四种名词含义，JavaScript、jQuery、AJAX、JSON 以及这四者之间的关系。 JavaScriptJavaScript（简称js）是一种主要运行于浏览器中的弱类型的动态脚本语言，可以用来实现网页上的一些高级功能，如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。 弱类型指的是js中的变量在参与运算的时候可以根据实际需要动态转换类型。与之相对应的是强类型语言——变量一般不允许自动转换类型（某些强类型语言的字符串连接操作除外），如果参与运算、调用时不符合要求的类型，则会在编译阶段报错，比如说java各种复杂的变量声明。","text":"在学习前端的过程中，经常被各种各样的语法名词搞混，这里简单归纳下容易混淆的四种名词含义，JavaScript、jQuery、AJAX、JSON 以及这四者之间的关系。 JavaScriptJavaScript（简称js）是一种主要运行于浏览器中的弱类型的动态脚本语言，可以用来实现网页上的一些高级功能，如数据验证处理、页面动态效果、定时任务、与用户交互、发送/接收服务器端数据等等。 弱类型指的是js中的变量在参与运算的时候可以根据实际需要动态转换类型。与之相对应的是强类型语言——变量一般不允许自动转换类型（某些强类型语言的字符串连接操作除外），如果参与运算、调用时不符合要求的类型，则会在编译阶段报错，比如说java各种复杂的变量声明。而因为JavaScript 是脚本语言。浏览器会在读取代码时，逐行地执行脚本代码。对于传统编程来说，则是会在执行前对所有代码进行编译。又因为他弱语言的特性，经常见到var出一切变量！ 简单的js示例： 1234567891011&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=\"text/javascript\"&gt;&#123; document.write(\"&lt;h1&gt;这是标题&lt;/h1&gt;\"); document.write(\"&lt;p&gt;Hello word！&lt;/p&gt;\"); document.write(\"&lt;p&gt;这是另一个段落。&lt;/p&gt;\"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; jQueryjQuery是js的一个工具库，由John Resig在2006年发布。意思就是基于js的一种实用工具。在jQuery出现之前，在js程序中获取元素节点比较麻烦，例如： 1document.getElementById('id') 之后John Resig根据css选择器编写了jQuery选择器，并对选择器的规则进行了扩充，从而让元素查找变得非常方便。 1$('#id') 除此之外还有链式操作 123$('div.con') .height(100) .show(); 这种连续调用可以让代码书写更加简洁，也印证了jQuery自己的口号：write less, do more 此外，jQuery还提供了浏览器兼容、样式读写、事件绑定与执行、动画等特性，后来又加入了ajax、promise等，再加上方便的插件编写机制，对整个js的生态圈产生了重大的影响，可以说是js历史上影响力最大的一个库。 AJAXajax全称Asynchronous JavaScript and XML（异步的JavaScript与XML），是网页无需刷新页面、使用js与服务器进行交互的一种技术。 有时候会有这样一种需求：只希望更改页面上的一个区域。然而在从前的技术框架内只能刷新整个页面，带来的后果是：①需要重新传输整个页面，服务器端与客户端的流量消耗都会比较大；②如果是动态页，服务器端需要重新生成整个页面，即使是那些客户原本不想要刷新的区域，增大了服务器的负担。 ajax的基本流程可以概括为：页面上js脚本实例化一个XMLHttpRequest对象，设置好服务器端的url、必要的查询参数、回调函数之后，向服务器发出请求，服务器在处理请求之后将处理结果返回给页面，触发事先绑定的回调函数。这样，页面脚本如果想要改变一个区域的内容，只需要通过ajax向服务器获取与该区域有关的少量数据，在回调函数中将该区域的内容替换掉即可，不需要刷新整个页面。 XMLHttpRequest在发送请求的时候，有两种方式：同步与异步。这里就不细谈了。 简单的示例： 12345678910$.ajax(&#123; url:'/user/ajaxshow', //规定发送请求的 URL。默认是当前页面。 method:'GET', //与type一模一样，只是type对于目前jQuery的版本全部兼容，method在jQuery1.9以后的版本 contentType:'application/json', //发送数据到服务器时所使用的内容类型。 dataType:'json', //预期的服务器响应的数据类型。 success:function (data) &#123; /**在此进行数据处理*/ alert(data); &#125; &#125; JSONJSON全称JavaScript Object Notation（js对象标记法），由Douglas Crockford在2002年发现并制定了标准。JSON是基于JavaScript的，是JavaScript的一个子集。JSON是用JavaScript语法来表示数据的一种轻量级语言。 从ajax的命名中我们就可以看到，数据交换是通过XML格式进行的。在ajax刚出现的时候，绝大多数应用都是采用XML格式，也有少数使用纯文本的。但是XML格式有一个缺点，就是文档构造复杂，需要传输比较多的字节数。在这种情况下，JSON的轻便性逐渐得到重视，后来替代XML成为ajax最主要的数据传输格式。可以举个简单的例子比较一下： 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;root&gt; &lt;article&gt; &lt;title&gt;Article Title1&lt;/title&gt; &lt;content&gt;content1&lt;/content&gt; &lt;/article&gt; &lt;article&gt; &lt;title&gt;Article Title2&lt;/title&gt; &lt;content&gt;content2&lt;/content&gt; &lt;/article&gt;&lt;/root&gt; 123456789101112&#123; \"article\" : [ &#123; \"title\": \"Article Title1\", \"content\": \"content1\" &#125;, &#123; \"title\": \"Article Title2\", \"content\": \"content2\" &#125; ]&#125; 说到js自身，对于对象构造有两种方法：基于对象的完整写法，字面量表示法。前者如： 123var obj = new Object();obj.title = \"title1\";obj.content = \"content1\"; 而与之对应的字面量表示法则写为： 1234var obj = &#123; title: \"title1\", content: \"content1\"&#125;; 可以明显看出字面量表示法要简洁得多。而JSON基本就是字面量表示法的一个子集，除了强制要求键与字符串类型的值必须用双引号包起之外，它剔除了undefined、function等类型，也不包括浏览器内置对象类型（如Date、RegExp等），是基于文本的、比较纯粹的数据表示方法。 总结总结一下就是，js老大哥，jQuery是他手头最好用的工具（之一），AJAX是基于js的一门页面部分刷新技术，JSON是js部分语法的升级优化版。","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"卸载win10预装","slug":"简单完全删除所有win10预装应用","date":"2018-10-13T13:36:53.000Z","updated":"2018-12-19T14:56:10.000Z","comments":true,"path":"2018/10/13/简单完全删除所有win10预装应用/","link":"","permalink":"http://yoursite.com/2018/10/13/简单完全删除所有win10预装应用/","excerpt":"","text":"一行命令删除所有win10预装应用，解决win10烦恼！！ 方法和步骤：1、搜索栏中输入“PowerShell”，在搜索结果中右键选择“以管理员身份运行”PowerShell。2、在PowerShell窗口中，输入“Get-AppXPackage | Remove-AppxPackage”回车确认，然后等待系统自动将当前账户中的所有预装应用都删除即可。3、如果要卸载某个应用，只需输入对应命令，按下回车键即可删除。","categories":[{"name":"电脑技巧","slug":"电脑技巧","permalink":"http://yoursite.com/categories/电脑技巧/"}],"tags":[{"name":"win10","slug":"win10","permalink":"http://yoursite.com/tags/win10/"}]},{"title":"我的博客之路","slug":"我的博客之路","date":"2017-12-11T13:36:53.000Z","updated":"2018-12-19T15:18:14.000Z","comments":true,"path":"2017/12/11/我的博客之路/","link":"","permalink":"http://yoursite.com/2017/12/11/我的博客之路/","excerpt":"说到博客，仿佛已经是多少年代以前的产物了。但是对于步入互联网行业的我来说，博客似乎占用了生活中很大一部分的，刚开始入门碰到各种各样的问题，百度出来很大一部分都是各个勤劳的博客主解决了问题，这也使得我在成长的道路上遇到各种与我或者我们一起在前行的人们，尽管时过境迁，他们或为销声匿迹或者也开启了自己的博客主之路，在被评论为大神时候，回想起的是当初稚嫩的自己第一次配置好IDE的满足，第一次在教程下print出Hello Word的喜悦，或者是写出第一篇博客的忐忑，以及无人问津的失落。 说起我为什么开始写博客，当时只是因为在同学的一句话下便萌生了写博客的心思，因为我也是一个喜欢折腾的人，那时候左思右想是在CSDN写好呢还是在博客园写下第一篇历史性的Hello。","text":"说到博客，仿佛已经是多少年代以前的产物了。但是对于步入互联网行业的我来说，博客似乎占用了生活中很大一部分的，刚开始入门碰到各种各样的问题，百度出来很大一部分都是各个勤劳的博客主解决了问题，这也使得我在成长的道路上遇到各种与我或者我们一起在前行的人们，尽管时过境迁，他们或为销声匿迹或者也开启了自己的博客主之路，在被评论为大神时候，回想起的是当初稚嫩的自己第一次配置好IDE的满足，第一次在教程下print出Hello Word的喜悦，或者是写出第一篇博客的忐忑，以及无人问津的失落。 说起我为什么开始写博客，当时只是因为在同学的一句话下便萌生了写博客的心思，因为我也是一个喜欢折腾的人，那时候左思右想是在CSDN写好呢还是在博客园写下第一篇历史性的Hello。最后还是想装一下的选择了hexo框架搭建的Github Page。当时hexo s看到自己博客终于显示出来得时候，内心是充满激动地，最后又花了一天零零散散的配置比如动态背景，live2d等等花里胡哨的东西，本想着与别人分享一下我成功的喜悦，但是，又想到这其实并没有什么大不了的，不是么，都没有什么内容充实，于是便就此搁浅。 为什么要写博客？这能说出好多好多的理由，但其实最让我警醒就是，当今互联网产生的碎边化阅读。时常浏览知乎的时候，我就感受到了，我看了很多很多的知识，到头来其实所剩无几，更别谈消化吸收了多少东西。博客就是一个很好的整理知识的途径，一来记录自己所学，二来记录自己所思。在其之后就是每个人不一样的小心思了，我也想成为别人口中的大V，或者是我想认识一些同样圈子的人，或者我想为简历添加重量级的一笔等等不一而足。 其实本来写博客就不会产生不良影响不是么，甚至是他还会给你带来很多的好处，可能出现的问题那其实都足以被其优点掩盖，那你还有什么理由不去写他。 解决了为什么要去写的问题，剩下来的就是怎么写了。就像刘未鹏所说的那样，让你自己成为一个持续学习和思考的人，并只写你真正思考和总结之后的产物，其他一切就会随之而来。其实就这么简单，如果你的确在社会中，或者是在校园里，那你总是有每天学到的东西。可能是你突然冒出来的一个疑问，你可以先记录下来然后顺藤摸瓜的就能拉出来好多相关的知识，我想各行各业的翘楚们所涵盖的内容，都足以使你发表一篇论文了。 时间总会说明一切的问题，慢慢的博客他就会成为你生活里一位挚友，你向他述说你收获的喜悦，向他抒发文艺的情绪，甚至开始写起小说等等。我也祝愿每一位有意无意看到的人都能有所得，因为，这就是生活啊。 这里贴上刘未鹏的《为什么你应该（从现在开始就）写博客》http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"起点","slug":"起点","permalink":"http://yoursite.com/tags/起点/"}]},{"title":"刚开始的一小步","slug":"刚开始的一小步","date":"2017-12-10T13:36:53.000Z","updated":"2018-12-19T14:40:30.000Z","comments":true,"path":"2017/12/10/刚开始的一小步/","link":"","permalink":"http://yoursite.com/2017/12/10/刚开始的一小步/","excerpt":"","text":"如往常一样，这只是一生中一样普通的一天。 –欢迎来到博客： https://ancientlian.github.io/","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"起点","slug":"起点","permalink":"http://yoursite.com/tags/起点/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-12-10T12:36:53.000Z","updated":"2018-12-19T14:40:26.000Z","comments":true,"path":"2017/12/10/hello-world/","link":"","permalink":"http://yoursite.com/2017/12/10/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}